<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stranger Lights — Controller</title>
<style>
  :root{ --led:#ff3b3b; --cell-size:44px; }
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#070809;color:#eee}
  .wrap{max-width:1100px;margin:12px auto;padding:12px}
  .header{display:flex;justify-content:space-between;align-items:center}
  .controls{display:flex;gap:8px;align-items:center}
  .image-wrap{position:relative;max-width:900px;margin-top:12px}
  img.bg{width:100%;display:block;border-radius:6px}
  .hotspot{position:absolute;width:var(--cell-size);height:var(--cell-size);transform:translate(-50%,-50%);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#111;background:rgba(255,255,255,0.03);user-select:none;touch-action:none;transition:filter .08s,transform .12s,box-shadow .12s}
  .hotspot.editing{outline:2px dashed rgba(255,255,255,0.06)}
  .hotspot .lbl{font-size:12px;display:none}
  .hotspot.on{background:var(--led); box-shadow:0 12px 28px rgba(255,59,59,0.18); transform:translate(-50%,-50%) scale(1.04)}
  .panel{margin-top:12px}
  button,input,select{padding:8px;border-radius:6px;border:0}
  .small{font-size:13px;color:#cbd}
  nav{display:flex;gap:12px;justify-content:center;padding:8px 0;margin-bottom:4px;border-bottom:1px solid rgba(255,255,255,0.08);font-size:14px}
  nav a{color:#cde;text-decoration:none}
  nav a:hover{text-decoration:underline}
</style>
</head>
<body>

<nav>
  <a href="./index.html">Viewer</a>
  <a href="./controller.html">Controller</a>
</nav>

<div class="wrap">
  <div class="header">
    <h2>Stranger Lights — Controller</h2>
    <div class="controls">
      <label class="small">Mode
        <select id="mode">
          <option value="all">All</option>
          <option value="rand">Random</option>
          <option value="word">Word</option>
        </select>
      </label>
      <label class="small">Speed
        <input id="speed" type="number" value="300" min="20" style="width:90px">
      </label>
      <label class="small">Color
        <input id="color" type="color" value="#ff3b3b">
      </label>
      <button id="toggleEdit">Enter Edit</button>
      <button id="savePos">Save</button>
    </div>
  </div>

  <div class="image-wrap" id="imageWrap">
    <img id="bg" class="bg" src="wall-bg.png" alt="wall-bg.png (place file next to html)" />
  </div>

  <div class="panel">
    <div style="margin-top:8px">
      <input id="word" placeholder="Type sentence (A–Z)" style="width:60%"/>
      <button id="startBtn">Start</button>
      <button id="stopBtn">Stop</button>
    </div>
    <p class="small">Open <b>index.html</b> (Viewer) in another tab to watch live. Check Console for debug logs.</p>
  </div>
</div>

<script>
/* --- Config & Storage keys --- */
const STORAGE_POS = 'st_positions_v1';
const STORAGE_STATE = 'st_last_state_v1';
const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
const imageWrap = document.getElementById('imageWrap');
const bg = document.getElementById('bg');
const toggleEditBtn = document.getElementById('toggleEdit');
const savePosBtn = document.getElementById('savePos');
const colorEl = document.getElementById('color');
const modeEl = document.getElementById('mode');
const speedEl = document.getElementById('speed');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const wordEl = document.getElementById('word');

let positions = null;        // array of {x, y}
let hotspotEls = [];         // DOM nodes
let editMode = false;
let dragging = null;         // {el, idx}

/* --- Utilities --- */
function defaultPositions(){
  const rows=[8,9,9], y=[20,44,68];
  const out=[];
  for(let r=0;r<rows.length;r++){
    for(let i=0;i<rows[r];i++){
      out.push({ x: +(((i+1)/(rows[r]+1))*100).toFixed(2), y: y[r] });
    }
  }
  return out;
}
function loadPositions(){
  try{
    const raw = localStorage.getItem(STORAGE_POS);
    if(raw){
      const p = JSON.parse(raw);
      if(Array.isArray(p) && p.length===26){
        positions = p;
        console.log('Loaded positions from storage');
        return;
      }
    }
  }catch(e){ console.warn('pos load err', e); }
  positions = defaultPositions();
  console.log('Using default positions');
}

/* --- Create hotspots and attach listeners (re-usable) --- */
function createHotspots(){
  hotspotEls.forEach(h=>h.remove());
  hotspotEls = [];
  for(let i=0;i<26;i++){
    const el = document.createElement('div');
    el.className = 'hotspot';
    el.dataset.i = i;
    el.innerHTML = `<div class="lbl">${letters[i]}</div>`;
    const p = positions[i] || {x:5,y:5};
    el.style.left = p.x + '%';
    el.style.top  = p.y + '%';
    el.addEventListener('pointerdown', onPointerDown);
    el.addEventListener('click', onHotspotClick);
    imageWrap.appendChild(el);
    hotspotEls.push(el);
  }
  applyColor(colorEl.value);
}

/* --- Color apply --- */
function applyColor(hex){
  document.documentElement.style.setProperty('--led', hex);
  hotspotEls.forEach(h=> h.style.setProperty('--glow', hex + '33'));
}
colorEl.addEventListener('input', ()=> applyColor(colorEl.value));

/* --- Edit mode controls --- */
function setEdit(on){
  editMode = !!on;
  hotspotEls.forEach(h=> {
    h.classList.toggle('editing', editMode);
    h.querySelector('.lbl').style.display = editMode ? 'block' : 'none';
  });
  toggleEditBtn.textContent = editMode ? 'Exit Edit' : 'Enter Edit';
  console.log('Edit mode', editMode);
}
toggleEditBtn.addEventListener('click', ()=> setEdit(!editMode));

/* --- Drag & drop / click-to-place --- */
let selectedForPlace = null;

function onHotspotClick(e){
  if(!editMode) return;
  const idx = +e.currentTarget.dataset.i;
  selectedForPlace = idx;
  hotspotEls.forEach((h,i)=> h.querySelector('.lbl').style.display = (i===idx)?'block':'none');
  console.log('Selected hotspot for click-to-place:', idx);
}

function onPointerDown(e){
  if(!editMode) return;
  e.preventDefault();
  const el = e.currentTarget;
  const idx = +el.dataset.i;
  dragging = { el, idx };
  el.setPointerCapture(e.pointerId);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}

function onPointerMove(e){
  if(!dragging) return;
  const rect = bg.getBoundingClientRect();
  let px = e.clientX - rect.left, py = e.clientY - rect.top;
  px = Math.max(0, Math.min(rect.width, px)); py = Math.max(0, Math.min(rect.height, py));
  const x = +(px/rect.width*100).toFixed(2), y = +(py/rect.height*100).toFixed(2);
  dragging.el.style.left = x + '%'; dragging.el.style.top = y + '%';
  positions[dragging.idx] = { x, y };
}

function onPointerUp(){
  if(!dragging) return;
  window.removeEventListener('pointermove', onPointerMove);
  window.removeEventListener('pointerup', onPointerUp);
  console.log('Dropped hotspot', dragging.idx, positions[dragging.idx]);
  dragging = null;
}

/* click-to-place on image */
imageWrap.addEventListener('click', function(e){
  if(!editMode || selectedForPlace === null) return;
  const rect = bg.getBoundingClientRect();
  let px = e.clientX - rect.left, py = e.clientY - rect.top;
  px = Math.max(0, Math.min(rect.width, px)); py = Math.max(0, Math.min(rect.height, py));
  const x = +(px/rect.width*100).toFixed(2), y = +(py/rect.height*100).toFixed(2);
  const el = hotspotEls[selectedForPlace];
  el.style.left = x + '%'; el.style.top = y + '%';
  positions[selectedForPlace] = { x, y };
  selectedForPlace = null;
  hotspotEls.forEach(h=> h.querySelector('.lbl').style.display = 'none');
  console.log('Placed hotspot via click at', positions);
});

/* --- Save positions --- */
savePosBtn.addEventListener('click', ()=>{
  hotspotEls.forEach((h,i)=> {
    positions[i] = { x: parseFloat(h.style.left||'0'), y: parseFloat(h.style.top||'0') };
  });
  localStorage.setItem(STORAGE_POS, JSON.stringify(positions));
  console.log('Positions saved');
  alert('Positions saved locally.');
});

/* --- Broadcast state to viewer(s) --- */
const bc = ('BroadcastChannel' in window) ? new BroadcastChannel('st-lights') : null;
function broadcastState(state){
  state.timestamp = Date.now();
  try{ if(bc) bc.postMessage(state); } catch(e){ console.warn('bc post failed',e); }
  try{
    localStorage.setItem(STORAGE_STATE, JSON.stringify(state));
    localStorage.setItem('st_last_update', Date.now());
  }catch(e){}
  console.log('Broadcasted state', state);
}

/* --- Preview helpers --- */
function clearAll(){ hotspotEls.forEach(h => { h.classList.remove('on'); h.style.filter='none'; }) }
function setIndex(i){ clearAll(); if(i>=0 && i<26) hotspotEls[i].classList.add('on'); }
function applyMask(mask){ clearAll(); for(let i=0;i<26;i++) if(mask & (1<<i)) hotspotEls[i].classList.add('on'); }

let flickInt = null;
function startFlicker(intensity){
  stopFlicker();
  const iv = Math.max(0, Math.min(100, Number(intensity||30)));
  flickInt = setInterval(()=> {
    hotspotEls.forEach(h=>{
      if(!h.classList.contains('on')) return h.style.filter='none';
      const jitter = (Math.random()*0.3 - 0.1) * (iv/50);
      const b = Math.max(0.75, 1 + jitter);
      h.style.filter = `brightness(${b})`;
    });
  }, 110);
}
function stopFlicker(){ if(flickInt) clearInterval(flickInt); flickInt=null; hotspotEls.forEach(h=> h.style.filter='none'); }

/* --- Controller loop --- */
let running = false;
async function controllerLoop(){
  if(running) return;
  running = true;
  while(running){
    const mode = modeEl.value;
    const speed = Math.max(20, Number(speedEl.value||300));
    const color = colorEl.value;
    const word = (wordEl.value||'').toUpperCase().replace(/[^A-Z ]/g,'');

    if(mode === 'all'){
      const on = Math.floor(Date.now()/speed) % 2 === 0;
      if(on){
        applyMask((1<<26)-1);
        broadcastState({ mode:'all', speed, mask: (1<<26)-1, color });
      } else {
        clearAll();
      }
      startFlicker(30);
      await new Promise(r => setTimeout(r, speed));
      continue;
    }

    if(mode === 'rand'){
      let mask = 0;
      for(let i=0;i<26;i++) if(Math.random() < 0.35) mask |= (1<<i);
      applyMask(mask);
      broadcastState({ mode:'rand', speed, mask, color });
      startFlicker(30);
      await new Promise(r => setTimeout(r, speed));
      continue;
    }

    if(mode === 'word'){
      if(!word){
        clearAll();
        await new Promise(r=>setTimeout(r,speed));
        continue;
      }
      const words = word.split(/\s+/).filter(Boolean);
      for(const w of words){
        const wordColor = '#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');
        for(const ch of w){
          const idx = ch.charCodeAt(0)-65;
          if(idx>=0 && idx<26){
            setIndex(idx);
            broadcastState({ mode:'word', speed, currentIndex: idx, word, color: wordColor });
          }
          startFlicker(30);
          await new Promise(r=>setTimeout(r, speed));
          if(!running) break;
        }
        clearAll();
        await new Promise(r=>setTimeout(r, speed/2));
        if(!running) break;
      }
      continue;
    }

    await new Promise(r => setTimeout(r, 200));
  }
}
startBtn.addEventListener('click', ()=> { if(!running) controllerLoop(); });
stopBtn.addEventListener('click', ()=> { running=false; stopFlicker(); clearAll(); });

/* --- Init --- */
loadPositions();
createHotspots();
applyColor(colorEl.value);
console.log('Editor/Controller ready — hotspots created:', hotspotEls.length);
window.__editor = { positions, hotspotEls };
</script>
</body>
</html>
